import org.apache.tools.ant.taskdefs.condition.Os


plugins {
    id 'java'
    id 'jacoco'
    id "de.undercouch.download" version "5.4.0"
}

group = project.group
version = project.version
evaluationDependsOn(':tool-migen-cli')

def ballerinaDist = "${layout.buildDirectory.get()}/jballerina-tools-${ballerinaLangVersion}"
def tomlVersion = stripBallerinaExtensionVersion("${project.version}")
def balToolFile = new File("$project.projectDir/resources/bal-tools.toml")

repositories {
    mavenCentral()
    maven {
        url = 'https://maven.wso2.org/nexus/content/repositories/releases/'
    }
    maven {
        url = 'https://maven.wso2.org/nexus/content/groups/wso2-public/'
    }
}

dependencies {
    implementation 'info.picocli:picocli:4.0.1'
    implementation "org.ballerinalang:ballerina-lang:${ballerinaLangVersion}"
    implementation "org.ballerinalang:ballerina-cli:${ballerinaLangVersion}"
    implementation "org.ballerinalang:ballerina-parser:${ballerinaLangVersion}"
    implementation "org.ballerinalang:ballerina-tools-api:${ballerinaLangVersion}"
    implementation "org.ballerinalang:diagram-util:${ballerinaLangVersion}"
    implementation "org.apache.ws.commons.axiom:axiom-api:${axiomVersion}"
    implementation "org.wso2.carbon.module:module-core:${carbonModuleCoreVersion}"
    implementation "org.wso2.integration.connector.core:mi-connector-core:${integrationConnectorCoreVersion}"
    implementation "org.apache.axis2.wso2:axis2:${axis2Version}"
    implementation "org.apache.synapse:synapse-core:${synapseVersion}"

    testImplementation 'org.testng:testng:7.7.0'
    testImplementation 'org.testcontainers:testcontainers:2.0.2'
    testImplementation 'io.rest-assured:rest-assured:5.4.0'
    testImplementation 'io.rest-assured:json-path:5.4.0'
    testImplementation 'io.rest-assured:xml-path:5.4.0'
    testImplementation 'org.mockito:mockito-core:5.8.0'
    testImplementation 'com.google.code.gson:gson:2.10.1'
    testImplementation "com.github.jknack:handlebars:${handlebarsVersion}"
    implementation project(':mi-native')
}

// The CLI project disables the regular jar (replaced by shadow jar), so we can't use
// testImplementation project(':tool-migen-cli'). Instead, wire in the class output
// and the compile classpath directly using Gradle 8-compatible API.
afterEvaluate {
    dependencies {
        testImplementation files(project(':tool-migen-cli').sourceSets.main.output)
        testImplementation files(project(':tool-migen-cli').configurations.compileClasspath)
    }
}


def projects = ['project2', 'project3', 'arrayProject', 'recordProject', 'jsonProject', 'mapProject',
                'primitiveTypeProject', 'unionProject', 'overwriteBodyProject', 'tableProject']
def toolVersion = stripBallerinaExtensionVersion("${project.version}")
// Define balCommand to use the test-specific distribution
ext.balCommand = Os.isFamily(Os.FAMILY_WINDOWS)
        ? "${ballerinaDist}/bin/bal.bat"
        : "${ballerinaDist}/bin/bal"

def stripBallerinaExtensionVersion(String extVersion) {
    if (extVersion.matches(project.ext.timestampedVersionRegex)) {
        def splitVersion = extVersion.split('-')
        if (splitVersion.length > 3) {
            def strippedValues = splitVersion[0..-4]
            return strippedValues.join('-')
        } else {
            return extVersion
        }
    } else {
        return extVersion.replace("${project.ext.snapshotVersion}", '')
    }
}

task jBallerinaPack {
    doLast {
        configurations.jbalTools.resolvedConfiguration.resolvedArtifacts.each { artifact ->
            copy {
                from project.zipTree(artifact.getFile())
                into layout.buildDirectory
            }
            copy {
                from(project.zipTree(artifact.getFile())) {
                    eachFile { fcd ->
                        fcd.relativePath = new RelativePath(!fcd.file.isDirectory(),
                            fcd.relativePath.segments.drop(1))
                    }
                    includeEmptyDirs = false
                }
                into ballerinaDist
            }
        }
    }
    outputs.dir ballerinaDist
}

task unpackStdLibs() {
    dependsOn(jBallerinaPack)
    doLast {
        configurations.ballerinaStdLibs.resolvedConfiguration.resolvedArtifacts.each { artifact ->
            copy {
                from project.zipTree(artifact.getFile())
                into layout.buildDirectory.dir("extracted-stdlibs/" + artifact.name + "-zip")
            }
        }
    }
}

task copyStdlibs() {
    dependsOn(unpackStdLibs)

    /* Standard Libraries */
    doLast {
        configurations.ballerinaStdLibs.resolvedConfiguration.resolvedArtifacts.each { artifact ->
            def artifactExtractedPath = "${layout.buildDirectory.get()}/extracted-stdlibs/" + artifact.name + "-zip"
            copy {
                into ballerinaDist
                into("repo/bala") {
                    from "${artifactExtractedPath}/bala"
                }
                into("repo/cache") {
                    from "${artifactExtractedPath}/cache"
                }
            }
        }
    }
}

task updateBalToolTomlFile {
    dependsOn(jBallerinaPack)
    doLast {
        def newBallerinaToml = balToolFile.text.replace("@toml.version@", tomlVersion)
        // Add new bal-tools.toml file to the ballerina-distribution/resources directory
        def ballerinaTomlFile = new File("${ballerinaDist}/resources/bal-tools.toml")
        // create new file if it does not exist
        if (!ballerinaTomlFile.exists()) {
            ballerinaTomlFile.getParentFile().mkdirs()
            ballerinaTomlFile.createNewFile()
        }
        ballerinaTomlFile.text = newBallerinaToml
    }
}

task pushMiToolToLocal() {
    dependsOn(":tool-migen:build")
    dependsOn(updateBalToolTomlFile)
    doLast {
        // First run bal pack to create the bala file
        exec {
            workingDir "${project.rootDir}/tool-migen"
            if (Os.isFamily(Os.FAMILY_WINDOWS)) {
                commandLine 'cmd', '/c', "${balCommand}", 'pack'
            } else {
                commandLine 'sh', '-c', "${balCommand} pack"
            }
        }

        // Then push to local repository
        // This will automatically update bal-tools.toml
        exec {
            workingDir "${project.rootDir}/tool-migen"
            if (Os.isFamily(Os.FAMILY_WINDOWS)) {
                commandLine 'cmd', '/c', "${balCommand}", 'push', '--repository=local'
            } else {
                commandLine 'sh', '-c', "${balCommand} push --repository=local"
            }
        }
    }
}

task copyMiToolToCentral() {
    dependsOn pushMiToolToLocal
    doLast {
        // wso2 org tools are resolved from central repository, not local
        // Copy the tool from local to central repository
        def homeDir = System.getProperty("user.home")
        def localRepo = file("${homeDir}/.ballerina/repositories/local/bala/wso2/tool.migen")
        def centralRepo = file("${homeDir}/.ballerina/repositories/central.ballerina.io/bala/wso2")

        // Ensure central repo directory exists
        centralRepo.mkdirs()

        // Only copy if local repo exists
        if (localRepo.exists()) {
            copy {
                from localRepo
                into "${centralRepo}/tool.migen"
            }
            println "Copied MI tool from local to central repository"
        } else {
            throw new GradleException("MI tool not found in local repository: ${localRepo}")
        }
    }
}

task buildBallerinaProjects {
    dependsOn copyStdlibs
    dependsOn copyMiToolToCentral  // Ensure tool is available in central repo
    doLast {
        def command = projects.collect { "$balCommand build src/test/resources/ballerina/$it" }.join(' && ')
        exec {
            if (Os.isFamily(Os.FAMILY_WINDOWS)) {
                commandLine 'cmd', "/c", command
            } else {
                commandLine 'sh', "-c", command
            }
        }
    }
}

task copyBallerinaJars(type: Copy) {
    dependsOn("buildBallerinaProjects")
    projects.each { project ->
        from("src/test/resources/ballerina/${project}/target/bin/${project}.jar")
        into('src/test/resources/libs')
    }
}
compileTestJava.dependsOn("copyBallerinaJars")
processTestResources.dependsOn("copyBallerinaJars")

// Task to copy connector artifacts to MI project
task copyConnectorArtifactsToMiProject {
    dependsOn buildBallerinaProjects
    doLast {
        def projectRoot = project.rootDir
        def ballerinaProjectsDir = new File(projectRoot, "tests/src/test/resources/ballerina")
        def miConnectorsDir = new File(projectRoot, "tests/src/test/resources/mi/project1/src/main/wso2mi/resources/connectors")
        
        // Ensure destination directory exists
        miConnectorsDir.mkdirs()
        
        // Projects and their artifact files to copy
        def connectorProjects = [
            [project: "project3", artifact: "ballerina-connector-project3-1.0.0.zip"]
            // Add more projects here in the future:
            // [project: "project1", artifact: "ballerina-connector-project1-0.0.1.zip"],
            // [project: "project2", artifact: "ballerina-connector-project2-1.0.0.zip"],
            // [project: "project4", artifact: "ballerina-connector-project4-0.0.1.zip"],
        ]
        
        connectorProjects.each { config ->
            def projectName = config.project
            def artifactName = config.artifact
            
            // Try target directory first
            def sourceFile = new File(ballerinaProjectsDir, "${projectName}/target/${artifactName}")
            
            // If not found, try project root
            if (!sourceFile.exists()) {
                sourceFile = new File(ballerinaProjectsDir, "${projectName}/${artifactName}")
            }
            
            if (sourceFile.exists()) {
                def destFile = new File(miConnectorsDir, artifactName)
                copy {
                    from sourceFile
                    into miConnectorsDir
                    rename { artifactName }
                }
                println "Copied connector artifact: ${sourceFile.name} -> ${destFile.absolutePath}"
            } else {
                println "Warning: Artifact not found for project ${projectName}: ${artifactName}"
            }
        }
    }
}

// Task to build MI project CAR file
task buildMiProject(type: Exec) {
    dependsOn copyConnectorArtifactsToMiProject
    def miProjectDir = new File(project.rootDir, "tests/src/test/resources/mi/project1")
    workingDir miProjectDir
    
    doFirst {
        println "Building MI project CAR file..."
        println "Working directory: ${workingDir}"
        
        def mvnCommand
        if (Os.isFamily(Os.FAMILY_WINDOWS)) {
            def mvnwCmd = new File(miProjectDir, "mvnw.cmd")
            if (mvnwCmd.exists()) {
                mvnCommand = ['cmd', '/c', mvnwCmd.absolutePath]
            } else {
                // Fallback to system Maven
                mvnCommand = ['mvn.cmd']
            }
        } else {
            def mvnw = new File(miProjectDir, "mvnw")
            if (mvnw.exists()) {
                mvnw.setExecutable(true)
                mvnCommand = [mvnw.absolutePath]
            } else {
                // Fallback to system Maven
                mvnCommand = ['sh', '-c', 'mvn "$@"', '--']
            }
        }
        
        commandLine mvnCommand + ['clean', 'package', '-DskipTests']
        println "Using Maven command: ${mvnCommand.join(' ')}"
    }
    
    doLast {
        println "MI project CAR file built successfully"
    }
}

tasks.register("generateExpectedArtifacts", JavaExec) {
    group = "verification"
    description = "Regenerates expected connector artifacts used by tests."
    dependsOn copyStdlibs
    dependsOn copyMiToolToCentral
    dependsOn(":tool-migen-cli:build")
    dependsOn testClasses
    classpath = sourceSets.test.runtimeClasspath
    main = "io.ballerina.mi.test.util.TestArtifactGenerationUtil"

    doFirst {
        if (!project.hasProperty("artifactTarget")) {
            throw new GradleException("Provide -PartifactTarget=project1|project2|project3|project4|project5|project6|unionProject|nestedRecordConflictProject|tableProject|central")
        }
        args project.property("artifactTarget")
        if (project.hasProperty("centralPackage")) {
            systemProperty "centralPackage", project.property("centralPackage")
        }
        systemProperty "bal.command", balCommand.toString()
        systemProperty "project.root", project.rootDir.toString()
    }
}

test {
    dependsOn copyMiToolToCentral  // This depends on pushMiToolToLocal
    dependsOn copyStdlibs
    dependsOn(":tool-migen-cli:build")
    dependsOn buildMiProject  // Build MI project before running tests
    //dependsOn(":tool-compiler-plugin:build")

    systemProperty "bal.command", balCommand.toString()
    systemProperty "project.root", project.rootDir.toString()
    systemProperty "miVersion", project.findProperty("miVersion") ?: "4.5.0"

    if (System.getProperty('debug') == 'true') {
        jvmArgs '-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:5005'
    }
    useTestNG() {
        suites 'src/test/resources/testng.xml'
    }

    testLogging {
        events "passed", "skipped", "failed"
        exceptionFormat "full"
        showStandardStreams = true
    }

    dependencies {
        implementation fileTree(dir: 'src/test/resources/libs', include: '*.jar')
    }

    // On Windows, Docker/Testcontainers doesn't work, so ignore test failures
    // This is safe because integration tests that require Docker will be skipped
    ignoreFailures = Os.isFamily(Os.FAMILY_WINDOWS)

    // Handle skipped tests gracefully
    afterSuite { desc, result ->
        if (!desc.parent) {
            def output = "Results: ${result.resultType} (${result.testCount} tests, " +
                "${result.successfulTestCount} passed, " +
                "${result.failedTestCount} failed, " +
                "${result.skippedTestCount} skipped)"
            def startItem = '|  ', endItem = '  |'
            def repeatLength = startItem.length() + output.length() + endItem.length()
            println('\n' + ('=' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('=' * repeatLength))

            // Log information about skipped tests on Windows
            if (Os.isFamily(Os.FAMILY_WINDOWS) && result.failedTestCount > 0) {
                def xmlReport = file("${reporting.baseDir}/tests/test/TEST-org.ballerina.test.MiIntegrationTest.xml")
                if (xmlReport.exists()) {
                    def xmlContent = xmlReport.text
                    def skipExceptionCount = (xmlContent =~ /SkipException/).count()
                    def failureCount = (xmlContent =~ /<failure/).count()
                    if (skipExceptionCount > 0 && skipExceptionCount >= failureCount) {
                        logger.warn("All test failures are due to skipped tests (Docker unavailable on Windows). " +
                            "This is expected - Windows CI runners don't support Docker containers. " +
                            "Failures are ignored on Windows.")
                    }
                }
            }
        }
    }

    finalizedBy jacocoTestReport
}

jacocoTestReport {
    dependsOn test
    reports {
        xml.required = true
        html.required = true
    }
}

// Configure JaCoCo coverage after all projects are evaluated
gradle.projectsEvaluated {
    def coverageProjects = [
        project(':mi-native'),
        project(':tool-migen-cli')
    ]

    jacocoTestReport {
        // Set the class directories to include classes from dependent projects
        classDirectories.setFrom(files(coverageProjects.collect {
            it.sourceSets.main.output.classesDirs
        }))

        // Set the source directories to include source from dependent projects
        sourceDirectories.setFrom(files(coverageProjects.collect {
            it.sourceSets.main.allSource.srcDirs
        }))

        // Execution data comes from the test task of each project
        executionData.setFrom(files(
            "${buildDir}/jacoco/test.exec",
            coverageProjects.collect { "${it.buildDir}/jacoco/test.exec" }
        ))
        
        dependsOn(coverageProjects.collect { it.tasks.named('test') })
    }
}
